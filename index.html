<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Laboratoire d'Identification des Plastiques</title>
<style>
/* ==================== RESET & BASE ==================== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
  background: #e8e8e8;
  color: #333;
  overflow: hidden;
  height: 100vh;
  user-select: none;
  -webkit-user-select: none;
}

/* ==================== LAYOUT ==================== */
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-width: 1280px;
  margin: 0 auto;
}

header {
  background: linear-gradient(135deg, #2c6fbb, #1b4f8a);
  color: #fff;
  text-align: center;
  padding: 10px 20px;
  font-size: 1.35em;
  font-weight: 700;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  flex-shrink: 0;
}
header small {
  display: block;
  font-size: 0.55em;
  font-weight: 400;
  opacity: 0.85;
  margin-top: 2px;
}

#main-area {
  display: flex;
  flex: 1;
  min-height: 0;
  gap: 0;
}

/* ==================== SHELF (LEFT) ==================== */
#shelf {
  width: 155px;
  background: #f0ede8;
  border-right: 2px solid #ccc;
  padding: 12px 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0;
}
#shelf h3 {
  font-size: 0.85em;
  text-align: center;
  color: #555;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.sample-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  background: #fff;
  border: 2px solid #bbb;
  border-radius: 10px;
  cursor: grab;
  transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
  position: relative;
}
.sample-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  border-color: #888;
}
.sample-btn:active { cursor: grabbing; }
.sample-btn .swatch {
  width: 30px;
  height: 30px;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.15);
  flex-shrink: 0;
}
.sample-btn .label {
  font-size: 0.78em;
  font-weight: 600;
  line-height: 1.25;
  color: #333;
}
.sample-btn .density {
  font-size: 0.65em;
  font-weight: 400;
  color: #777;
}
.sample-btn.mystery-btn {
  border-color: #d4a017;
  background: #fffbe6;
}
.sample-btn.mystery-btn .swatch {
  background: linear-gradient(135deg, #f7dc6f, #f0b27a, #bb8fce, #76d7c4) !important;
}

/* ==================== CANVAS AREA ==================== */
#sim-container {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  position: relative;
  min-width: 0;
}
#sim-container canvas {
  background: #fdfdfd;
  border-radius: 8px;
  box-shadow: 0 2px 16px rgba(0,0,0,0.08);
}
#drop-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.1em;
  color: #aaa;
  pointer-events: none;
  text-align: center;
  line-height: 1.6;
  display: none;
}

/* ==================== TOOLS (RIGHT) ==================== */
#tools {
  width: 195px;
  background: #f0ede8;
  border-left: 2px solid #ccc;
  padding: 12px 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex-shrink: 0;
}
#tools h3 {
  font-size: 0.85em;
  text-align: center;
  color: #555;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.tool-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px;
  background: #fff;
  border: 2px solid #bbb;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.15s;
  font-size: 0.78em;
  font-weight: 600;
  color: #444;
}
.tool-btn:hover { border-color: #888; background: #f8f8f8; }
.tool-btn.active {
  border-color: #2c6fbb;
  background: #e8f0fc;
  color: #1b4f8a;
  box-shadow: 0 0 0 3px rgba(44,111,187,0.15);
}
.tool-btn .tool-icon {
  width: 32px;
  height: 32px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3em;
  flex-shrink: 0;
}
.tool-btn .tool-label { line-height: 1.3; }
.tool-btn .tool-label small { font-weight: 400; color: #777; display: block; font-size: 0.88em; }

/* Tool icons backgrounds */
.tool-icon.water { background: #d4ecff; }
.tool-icon.salt  { background: #b8d4f0; }
.tool-icon.acetone { background: #ffecd2; }
.tool-icon.flame { background: #ffe0d0; }

/* ==================== BOTTOM AREA ==================== */
#bottom-area {
  display: flex;
  gap: 0;
  flex-shrink: 0;
  border-top: 2px solid #ccc;
  height: 155px;
}

/* Log panel */
#log-panel {
  flex: 1;
  background: #fafaf7;
  padding: 8px 14px;
  display: flex;
  flex-direction: column;
}
#log-panel h3 {
  font-size: 0.8em;
  color: #555;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 6px;
  flex-shrink: 0;
}
#log-list {
  flex: 1;
  overflow-y: auto;
  font-size: 0.82em;
  line-height: 1.55;
}
#log-list .log-entry {
  padding: 4px 0;
  border-bottom: 1px solid #eee;
  display: flex;
  gap: 6px;
}
#log-list .log-entry .log-icon { flex-shrink: 0; }
#log-list .log-entry .log-text { color: #444; }
#log-list .log-entry .log-sample { font-weight: 700; }

/* Validation panel */
#validation-panel {
  width: 320px;
  background: #fffbe6;
  border-left: 2px solid #e0d8a8;
  padding: 10px 14px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
#validation-panel h3 {
  font-size: 0.8em;
  color: #8a7a20;
  text-transform: uppercase;
  letter-spacing: 1px;
}
#validation-panel p { font-size: 0.82em; color: #665; line-height: 1.4; }
#validation-panel select {
  padding: 6px 10px;
  border-radius: 6px;
  border: 2px solid #ccc;
  font-size: 0.9em;
  background: #fff;
}
#validate-btn {
  padding: 8px 16px;
  background: linear-gradient(135deg, #4CAF50, #388E3C);
  color: #fff;
  border: none;
  border-radius: 8px;
  font-size: 0.9em;
  font-weight: 700;
  cursor: pointer;
  transition: transform 0.1s, box-shadow 0.1s;
  align-self: flex-start;
}
#validate-btn:hover { transform: translateY(-1px); box-shadow: 0 3px 8px rgba(0,0,0,0.2); }
#validate-btn:active { transform: translateY(0); }
#validation-result {
  font-size: 0.9em;
  font-weight: 700;
  min-height: 1.5em;
}
#validation-result.success { color: #2e7d32; }
#validation-result.fail { color: #c62828; }

/* ==================== RESET BUTTON ==================== */
#reset-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 7px 16px;
  background: linear-gradient(135deg, #ff8a65, #e64a19);
  color: #fff;
  border: none;
  border-radius: 8px;
  font-size: 0.82em;
  font-weight: 700;
  cursor: pointer;
  z-index: 5;
  transition: transform 0.1s;
}
#reset-btn:hover { transform: translateY(-1px); }

/* ==================== DRAG GHOST ==================== */
.drag-ghost {
  position: fixed;
  pointer-events: none;
  z-index: 1000;
  opacity: 0.88;
  transform: translate(-50%, -50%) scale(1.15);
  filter: drop-shadow(0 4px 12px rgba(0,0,0,0.3));
}
.drag-ghost .swatch {
  width: 44px;
  height: 44px;
  border-radius: 8px;
  border: 2px solid rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 0.8em;
  color: rgba(0,0,0,0.5);
}

/* ==================== CONFETTI OVERLAY ==================== */
#confetti-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2000;
}

/* ==================== SCROLLBAR ==================== */
#log-list::-webkit-scrollbar { width: 6px; }
#log-list::-webkit-scrollbar-track { background: transparent; }
#log-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
</style>
</head>
<body>
<div id="app">
  <header>
    Laboratoire d'Identification des Plastiques
    <small>Glissez un echantillon depuis l'etagere vers la zone d'experience</small>
  </header>

  <div id="main-area">
    <!-- LEFT: Sample shelf -->
    <div id="shelf">
      <h3>Echantillons</h3>
      <div class="sample-btn" data-type="PE" draggable="false">
        <div class="swatch" style="background:#e8d44d;"></div>
        <div class="label">PE<br><span class="density">Polyethylene<br>œÅ = 0,95</span></div>
      </div>
      <div class="sample-btn" data-type="PS" draggable="false">
        <div class="swatch" style="background:#f0f0f0; border:1px solid #bbb;"></div>
        <div class="label">PS<br><span class="density">Polystyrene<br>œÅ = 1,05</span></div>
      </div>
      <div class="sample-btn" data-type="PVC" draggable="false">
        <div class="swatch" style="background:#a0a0a0;"></div>
        <div class="label">PVC<br><span class="density">Polychlorure<br>œÅ = 1,40</span></div>
      </div>
      <div class="sample-btn" data-type="PET" draggable="false">
        <div class="swatch" style="background:#87ceeb;"></div>
        <div class="label">PET<br><span class="density">Polyterephtalate<br>œÅ = 1,38</span></div>
      </div>
      <div class="sample-btn mystery-btn" data-type="MYSTERY" draggable="false">
        <div class="swatch"></div>
        <div class="label">? Inconnu<br><span class="density">A identifier !</span></div>
      </div>
    </div>

    <!-- CENTER: Simulation canvas -->
    <div id="sim-container">
      <canvas id="sim" width="660" height="470"></canvas>
      <div id="drop-hint">Selectionnez un test a droite,<br>puis glissez un echantillon ici.</div>
      <button id="reset-btn">Reinitialiser</button>
    </div>

    <!-- RIGHT: Tools -->
    <div id="tools">
      <h3>Tests</h3>
      <div class="tool-btn active" data-test="A">
        <div class="tool-icon water">üíß</div>
        <div class="tool-label">Eau douce<small>œÅ = 1,0 g/cm¬≥</small></div>
      </div>
      <div class="tool-btn" data-test="B">
        <div class="tool-icon salt">üßÇ</div>
        <div class="tool-label">Eau salee<small>œÅ = 1,2 g/cm¬≥</small></div>
      </div>
      <div class="tool-btn" data-test="C">
        <div class="tool-icon acetone">üß™</div>
        <div class="tool-label">Acetone<small>Solubilite</small></div>
      </div>
      <div class="tool-btn" data-test="D">
        <div class="tool-icon flame">üî•</div>
        <div class="tool-label">Test de flamme<small>Belstein (chlore)</small></div>
      </div>
    </div>
  </div>

  <!-- BOTTOM -->
  <div id="bottom-area">
    <div id="log-panel">
      <h3>Observations</h3>
      <div id="log-list"></div>
    </div>
    <div id="validation-panel">
      <h3>Identification du mystere</h3>
      <p>Effectuez les tests sur l'echantillon "?" puis identifiez-le :</p>
      <select id="guess-select">
        <option value="">-- Choisir --</option>
        <option value="PE">PE (Polyethylene)</option>
        <option value="PS">PS (Polystyrene)</option>
        <option value="PVC">PVC (Polychlorure de vinyle)</option>
        <option value="PET">PET (Polyterephtalate d'ethylene)</option>
      </select>
      <button id="validate-btn">Verifier</button>
      <div id="validation-result"></div>
    </div>
  </div>
</div>

<canvas id="confetti-canvas"></canvas>

<script>
/* ==================================================================
   SIMULATION INTERACTIVE D'IDENTIFICATION DES PLASTIQUES
   ================================================================== */

// ==================== CONSTANTS ====================
const PLASTICS = {
  PE:  { name: 'PE',  fullName: 'Polyethylene',             density: 0.95, color: '#e8d44d', darkColor: '#c4b030', dissolves: false, chlorine: false },
  PS:  { name: 'PS',  fullName: 'Polystyrene',              density: 1.05, color: '#e8e8e8', darkColor: '#b0b0b0', dissolves: true,  chlorine: false },
  PVC: { name: 'PVC', fullName: 'Polychlorure de vinyle',   density: 1.40, color: '#a0a0a0', darkColor: '#707070', dissolves: false, chlorine: true  },
  PET: { name: 'PET', fullName: "Polyterephtalate d'ethylene", density: 1.38, color: '#87ceeb', darkColor: '#5a9cb8', dissolves: false, chlorine: false },
};

const MYSTERY_TYPES = ['PE', 'PS', 'PVC', 'PET'];
const MYSTERY_TYPE = MYSTERY_TYPES[Math.floor(Math.random() * MYSTERY_TYPES.length)];
const MYSTERY_COLOR = '#c9a0dc';

const GRAVITY = 600;        // px/s¬≤
const WATER_DRAG = 4.5;     // damping coefficient in water
const BOB_AMPLITUDE = 2.5;  // gentle bobbing
const BOB_SPEED = 2.0;

const CANVAS_W = 660;
const CANVAS_H = 470;

// Beaker geometry
const BEAKER = { x: 330, y: 55, w: 240, h: 310, wallThick: 4, waterRatio: 0.78 };
// Dish geometry
const DISH = { x: 330, y: 250, w: 280, h: 70, liquidH: 40 };
// Burner geometry
const BURNER = { x: 330, baseY: 420, tubeW: 28, tubeH: 160, flameH: 80 };

const SAMPLE_SIZE = 38;

// ==================== STATE ====================
const state = {
  currentTest: 'A',
  mysteryType: MYSTERY_TYPE,
  dragging: null,       // { type: string, ghostEl: HTMLElement }
  mouseX: 0,
  mouseY: 0,
  anim: null,           // current animation object
  time: 0,
  logs: [],
  solved: false,
};

// ==================== DOM REFS ====================
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');
const dropHint = document.getElementById('drop-hint');
const logList = document.getElementById('log-list');
const confettiCanvas = document.getElementById('confetti-canvas');
const confettiCtx = confettiCanvas.getContext('2d');

// ==================== UTILITY ====================
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, mn, mx) { return Math.max(mn, Math.min(mx, v)); }
function getPlasticInfo(type) {
  if (type === 'MYSTERY') return { ...PLASTICS[state.mysteryType], name: '?', fullName: 'Inconnu' };
  return PLASTICS[type];
}
function getSampleColor(type) {
  return type === 'MYSTERY' ? MYSTERY_COLOR : PLASTICS[type].color;
}
function getSampleDarkColor(type) {
  return type === 'MYSTERY' ? '#9060a0' : PLASTICS[type].darkColor;
}
function getDisplayName(type) {
  return type === 'MYSTERY' ? '?' : type;
}

// ==================== LOGGING ====================
function addLog(icon, sampleType, text) {
  state.logs.push({ icon, sampleType, text });
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.innerHTML = `<span class="log-icon">${icon}</span><span class="log-text"><span class="log-sample">[${getDisplayName(sampleType)}]</span> ${text}</span>`;
  logList.appendChild(entry);
  logList.scrollTop = logList.scrollHeight;
}

// ==================== CANVAS DRAWING HELPERS ====================
function drawRoundRect(cx, x, y, w, h, r) {
  cx.beginPath();
  cx.moveTo(x + r, y);
  cx.lineTo(x + w - r, y);
  cx.quadraticCurveTo(x + w, y, x + w, y + r);
  cx.lineTo(x + w, y + h - r);
  cx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  cx.lineTo(x + r, y + h);
  cx.quadraticCurveTo(x, y + h, x, y + h - r);
  cx.lineTo(x, y + r);
  cx.quadraticCurveTo(x, y, x + r, y);
  cx.closePath();
}

function drawSample(cx, x, y, size, type, alpha, scale, darken) {
  cx.save();
  cx.globalAlpha = alpha || 1;
  cx.translate(x, y);
  cx.scale(scale || 1, scale || 1);
  const c = darken ? getSampleDarkColor(type) : getSampleColor(type);
  // body
  drawRoundRect(cx, -size/2, -size/2, size, size, 6);
  cx.fillStyle = c;
  cx.fill();
  cx.strokeStyle = 'rgba(0,0,0,0.25)';
  cx.lineWidth = 1.5;
  cx.stroke();
  // label
  cx.fillStyle = 'rgba(0,0,0,0.55)';
  cx.font = 'bold 13px Arial';
  cx.textAlign = 'center';
  cx.textBaseline = 'middle';
  cx.fillText(getDisplayName(type), 0, 0);
  cx.restore();
}

// ==================== BEAKER DRAWING ====================
function drawBeaker(cx, waterColor, label, waterDensity) {
  const bx = BEAKER.x - BEAKER.w/2;
  const by = BEAKER.y;
  const bw = BEAKER.w;
  const bh = BEAKER.h;
  const wt = BEAKER.wallThick;

  // Water
  const waterH = bh * BEAKER.waterRatio;
  const waterY = by + bh - waterH;

  // Water body
  cx.save();
  cx.beginPath();
  cx.rect(bx + wt, waterY, bw - 2*wt, waterH - wt);
  cx.clip();

  cx.fillStyle = waterColor;
  cx.fillRect(bx + wt, waterY, bw - 2*wt, waterH);

  // Subtle wave on surface
  const t = state.time;
  cx.beginPath();
  cx.moveTo(bx + wt, waterY + 12);
  for (let px = bx + wt; px <= bx + bw - wt; px += 2) {
    const wave = Math.sin((px - bx) * 0.04 + t * 2) * 3 + Math.sin((px - bx) * 0.07 + t * 3) * 1.5;
    cx.lineTo(px, waterY + wave);
  }
  cx.lineTo(bx + bw - wt, by);
  cx.lineTo(bx + wt, by);
  cx.closePath();
  cx.fillStyle = '#fdfdfd';
  cx.fill();
  cx.restore();

  // Glass body
  cx.strokeStyle = 'rgba(100,130,170,0.5)';
  cx.lineWidth = wt;
  cx.lineJoin = 'round';
  cx.beginPath();
  // left wall
  cx.moveTo(bx + wt/2, by);
  cx.lineTo(bx + wt/2, by + bh - wt/2);
  // bottom
  cx.lineTo(bx + bw - wt/2, by + bh - wt/2);
  // right wall
  cx.lineTo(bx + bw - wt/2, by);
  cx.stroke();

  // Lip at top
  cx.lineWidth = wt + 1;
  cx.beginPath();
  cx.moveTo(bx - 4, by);
  cx.lineTo(bx + wt/2, by);
  cx.stroke();
  cx.beginPath();
  cx.moveTo(bx + bw - wt/2, by);
  cx.lineTo(bx + bw + 4, by);
  cx.stroke();

  // Graduation marks
  cx.strokeStyle = 'rgba(100,130,170,0.3)';
  cx.lineWidth = 1;
  for (let i = 1; i <= 5; i++) {
    const gy = by + bh - (i / 6) * bh;
    cx.beginPath();
    cx.moveTo(bx + wt + 2, gy);
    cx.lineTo(bx + wt + 18, gy);
    cx.stroke();
  }

  // Glass highlight
  cx.fillStyle = 'rgba(255,255,255,0.12)';
  cx.fillRect(bx + wt + 4, by + 10, 14, bh - 30);

  // Label below beaker
  cx.fillStyle = '#555';
  cx.font = '13px Arial';
  cx.textAlign = 'center';
  cx.textBaseline = 'top';
  cx.fillText(label, BEAKER.x, by + bh + 12);
  cx.font = '11px Arial';
  cx.fillStyle = '#888';
  cx.fillText(`densite = ${waterDensity.toFixed(1)} g/cm¬≥`, BEAKER.x, by + bh + 28);
}

function getWaterSurfaceY() {
  return BEAKER.y + BEAKER.h - BEAKER.h * BEAKER.waterRatio;
}

function getBeakerBottomY() {
  return BEAKER.y + BEAKER.h - BEAKER.wallThick - SAMPLE_SIZE/2;
}

function getBeakerInnerLeft() { return BEAKER.x - BEAKER.w/2 + BEAKER.wallThick + SAMPLE_SIZE/2 + 4; }
function getBeakerInnerRight() { return BEAKER.x + BEAKER.w/2 - BEAKER.wallThick - SAMPLE_SIZE/2 - 4; }

// ==================== DISH DRAWING ====================
function drawDish(cx) {
  const dx = DISH.x - DISH.w/2;
  const dy = DISH.y;
  const dw = DISH.w;
  const dh = DISH.h;

  // Shadow
  cx.fillStyle = 'rgba(0,0,0,0.07)';
  cx.beginPath();
  cx.ellipse(DISH.x, dy + dh + 6, dw/2 + 6, 12, 0, 0, Math.PI * 2);
  cx.fill();

  // Dish body (side view: flat oval)
  cx.fillStyle = '#e8e8e8';
  cx.strokeStyle = 'rgba(100,130,170,0.4)';
  cx.lineWidth = 2.5;
  cx.beginPath();
  cx.ellipse(DISH.x, dy + dh, dw/2, 18, 0, 0, Math.PI * 2);
  cx.fill();
  cx.stroke();

  // Liquid
  cx.fillStyle = 'rgba(255,235,180,0.55)';
  cx.beginPath();
  cx.ellipse(DISH.x, dy + dh - 2, dw/2 - 10, 13, 0, 0, Math.PI * 2);
  cx.fill();

  // Dish rim (top ellipse)
  cx.fillStyle = '#f2f2f2';
  cx.strokeStyle = 'rgba(100,130,170,0.4)';
  cx.lineWidth = 2.5;
  cx.beginPath();
  cx.ellipse(DISH.x, dy, dw/2, 18, 0, 0, Math.PI * 2);
  cx.fill();
  cx.stroke();

  // Side walls
  cx.strokeStyle = 'rgba(100,130,170,0.3)';
  cx.lineWidth = 2;
  cx.beginPath();
  cx.moveTo(dx, dy);
  cx.lineTo(dx, dy + dh);
  cx.stroke();
  cx.beginPath();
  cx.moveTo(dx + dw, dy);
  cx.lineTo(dx + dw, dy + dh);
  cx.stroke();

  // Liquid visible inside (top surface)
  cx.fillStyle = 'rgba(255,235,180,0.4)';
  cx.beginPath();
  cx.ellipse(DISH.x, dy + 2, dw/2 - 12, 14, 0, 0, Math.PI * 2);
  cx.fill();

  // Label
  cx.fillStyle = '#555';
  cx.font = '13px Arial';
  cx.textAlign = 'center';
  cx.textBaseline = 'top';
  cx.fillText('Acetone', DISH.x, dy + dh + 28);
  cx.font = '11px Arial';
  cx.fillStyle = '#888';
  cx.fillText('Solvant organique', DISH.x, dy + dh + 44);
}

// ==================== BURNER & FLAME DRAWING ====================
function drawBunsenBurner(cx) {
  const bx = BURNER.x;
  const by = BURNER.baseY;
  const tw = BURNER.tubeW;
  const th = BURNER.tubeH;

  // Base
  cx.fillStyle = '#555';
  cx.beginPath();
  cx.ellipse(bx, by, 50, 14, 0, 0, Math.PI * 2);
  cx.fill();
  cx.fillStyle = '#666';
  cx.beginPath();
  cx.ellipse(bx, by - 3, 50, 14, 0, 0, Math.PI * 2);
  cx.fill();

  // Tube
  const grad = cx.createLinearGradient(bx - tw/2, 0, bx + tw/2, 0);
  grad.addColorStop(0, '#888');
  grad.addColorStop(0.3, '#bbb');
  grad.addColorStop(0.7, '#bbb');
  grad.addColorStop(1, '#888');
  cx.fillStyle = grad;
  cx.fillRect(bx - tw/2, by - th, tw, th);

  // Collar
  cx.fillStyle = '#777';
  cx.fillRect(bx - tw/2 - 4, by - th + 20, tw + 8, 16);

  // Air holes
  cx.fillStyle = '#555';
  cx.fillRect(bx - tw/2 - 4 + 5, by - th + 24, 6, 8);
  cx.fillRect(bx + tw/2 - 5, by - th + 24, 6, 8);

  // Top opening
  cx.fillStyle = '#444';
  cx.beginPath();
  cx.ellipse(bx, by - th, tw/2 + 1, 5, 0, 0, Math.PI * 2);
  cx.fill();

  // Label
  cx.fillStyle = '#555';
  cx.font = '13px Arial';
  cx.textAlign = 'center';
  cx.textBaseline = 'top';
  cx.fillText('Bec Bunsen', bx, by + 16);
  cx.font = '11px Arial';
  cx.fillStyle = '#888';
  cx.fillText('Test de Belstein', bx, by + 32);
}

function drawFlame(cx, baseX, baseY, flameColor, t) {
  const fh = BURNER.flameH;

  // Outer flame glow
  const outerGrad = cx.createRadialGradient(baseX, baseY - fh * 0.4, 5, baseX, baseY - fh * 0.3, fh * 0.7);
  outerGrad.addColorStop(0, flameColor + '40');
  outerGrad.addColorStop(1, 'transparent');
  cx.fillStyle = outerGrad;
  cx.beginPath();
  cx.ellipse(baseX, baseY - fh * 0.35, fh * 0.6, fh * 0.65, 0, 0, Math.PI * 2);
  cx.fill();

  // Draw several flame layers
  for (let i = 3; i >= 0; i--) {
    const s = 1 - i * 0.2;
    const h = fh * s;
    const w = 18 * s;
    const ox = Math.sin(t * 12 + i * 2.1) * (2.5 + i);
    const oy = Math.cos(t * 9 + i * 1.7) * 2;

    cx.beginPath();
    cx.moveTo(baseX + ox, baseY);
    cx.quadraticCurveTo(baseX + w + ox, baseY - h * 0.35 + oy, baseX + ox + Math.sin(t * 8 + i) * 3, baseY - h + oy);
    cx.quadraticCurveTo(baseX - w + ox, baseY - h * 0.35 + oy, baseX + ox, baseY);
    cx.closePath();

    if (i === 3) {
      cx.fillStyle = flameColor;
    } else if (i === 2) {
      cx.fillStyle = blendColor(flameColor, '#ffcc00', 0.3);
    } else if (i === 1) {
      cx.fillStyle = blendColor('#ffee88', '#ffffcc', 0.5);
    } else {
      cx.fillStyle = 'rgba(200,220,255,0.7)';
    }
    cx.globalAlpha = 0.7 + i * 0.08;
    cx.fill();
    cx.globalAlpha = 1;
  }
}

function blendColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  const r = Math.round(lerp(r1, r2, t)), g = Math.round(lerp(g1, g2, t)), b = Math.round(lerp(b1, b2, t));
  return '#' + r.toString(16).padStart(2,'0') + g.toString(16).padStart(2,'0') + b.toString(16).padStart(2,'0');
}

function getFlameTopY() {
  return BURNER.baseY - BURNER.tubeH - BURNER.flameH * 0.5;
}

// ==================== ANIMATION OBJECTS ====================

// --- Density test animation ---
function createDensityAnim(type, waterDensity) {
  const info = getPlasticInfo(type);
  const floats = info.density < waterDensity;
  const surfaceY = getWaterSurfaceY();
  const bottomY = getBeakerBottomY();

  // Float position: submerged ratio = density / waterDensity
  const submergedRatio = floats ? info.density / waterDensity : 1;
  const floatY = floats ? surfaceY - SAMPLE_SIZE/2 + SAMPLE_SIZE * submergedRatio : bottomY;

  return {
    type: type,
    phase: 'falling',  // 'falling', 'in_water', 'settled'
    x: BEAKER.x + (Math.random() - 0.5) * 60,
    y: BEAKER.y - 30,
    vy: 0,
    targetY: floatY,
    floats: floats,
    surfaceY: surfaceY,
    bottomY: bottomY,
    settleTime: 0,
    bobPhase: Math.random() * Math.PI * 2,
    splashParticles: [],
    logged: false,
    plasticInfo: info,
    waterDensity: waterDensity,
  };
}

function updateDensityAnim(anim, dt) {
  if (anim.phase === 'falling') {
    anim.vy += GRAVITY * dt;
    anim.y += anim.vy * dt;

    if (anim.y >= anim.surfaceY) {
      anim.phase = 'in_water';
      // Splash particles
      for (let i = 0; i < 8; i++) {
        anim.splashParticles.push({
          x: anim.x + (Math.random() - 0.5) * SAMPLE_SIZE,
          y: anim.surfaceY,
          vx: (Math.random() - 0.5) * 120,
          vy: -Math.random() * 180 - 40,
          life: 1,
          r: Math.random() * 3 + 1,
        });
      }
      anim.vy *= 0.3;
    }
  }

  if (anim.phase === 'in_water') {
    // Net force: positive = downward (sinks), negative = upward (floats)
    const netAccel = (anim.plasticInfo.density - anim.waterDensity) / anim.plasticInfo.density * GRAVITY;
    anim.vy += netAccel * dt;
    anim.vy *= (1 - WATER_DRAG * dt); // drag damping
    anim.y += anim.vy * dt;

    // Constrain to beaker bounds
    if (anim.floats) {
      if (anim.y < anim.targetY) {
        anim.y = anim.targetY;
        anim.vy = Math.abs(anim.vy) * 0.25;
      }
    } else {
      if (anim.y > anim.bottomY) {
        anim.y = anim.bottomY;
        anim.vy = -Math.abs(anim.vy) * 0.15;
      }
    }
    // Don't let it float above the water surface
    if (anim.y < anim.surfaceY - SAMPLE_SIZE/2) {
      anim.y = anim.surfaceY - SAMPLE_SIZE/2;
      anim.vy = Math.abs(anim.vy) * 0.2;
    }

    if (Math.abs(anim.vy) < 0.8 && Math.abs(anim.y - anim.targetY) < 3) {
      anim.phase = 'settled';
      anim.y = anim.targetY;
    }
  }

  if (anim.phase === 'settled') {
    anim.settleTime += dt;
    if (anim.floats) {
      anim.y = anim.targetY + Math.sin(anim.settleTime * BOB_SPEED + anim.bobPhase) * BOB_AMPLITUDE;
    }
    if (!anim.logged) {
      anim.logged = true;
      logDensityResult(anim);
    }
  }

  // Update splash particles
  anim.splashParticles.forEach(p => {
    p.vy += GRAVITY * dt * 0.5;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt * 2;
  });
  anim.splashParticles = anim.splashParticles.filter(p => p.life > 0);
}

function drawDensityAnim(cx, anim) {
  const sz = SAMPLE_SIZE;
  const bx = BEAKER.x - BEAKER.w/2 + BEAKER.wallThick;
  const bw = BEAKER.w - 2 * BEAKER.wallThick;
  const by = BEAKER.y;
  const bh = BEAKER.h - BEAKER.wallThick;

  // Draw sample, clipped to beaker interior
  cx.save();
  cx.beginPath();
  cx.rect(bx, by, bw, bh);
  cx.clip();
  drawSample(cx, anim.x, anim.y, sz, anim.type, 1, 1, false);
  cx.restore();

  // Draw sample above water level (unclipped) if above surface
  if (anim.y - sz/2 < anim.surfaceY) {
    cx.save();
    cx.beginPath();
    cx.rect(bx, by, bw, anim.surfaceY - by);
    cx.clip();
    drawSample(cx, anim.x, anim.y, sz, anim.type, 1, 1, false);
    cx.restore();
  }

  // Splash particles
  anim.splashParticles.forEach(p => {
    cx.globalAlpha = p.life * 0.6;
    cx.fillStyle = state.currentTest === 'A' ? 'rgba(130,190,255,0.7)' : 'rgba(80,140,210,0.7)';
    cx.beginPath();
    cx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    cx.fill();
    cx.globalAlpha = 1;
  });
}

function logDensityResult(anim) {
  const testName = state.currentTest === 'A' ? 'eau douce' : 'eau salee';
  const dn = getDisplayName(anim.type);
  const d = anim.plasticInfo.density;
  const wd = anim.waterDensity;
  if (anim.floats) {
    addLog('üíß', anim.type,
      `flotte dans l'${testName}. Densite (${d.toFixed(2)}) < ${testName} (${wd.toFixed(1)}).`);
  } else {
    addLog('üíß', anim.type,
      `coule dans l'${testName}. Densite (${d.toFixed(2)}) > ${testName} (${wd.toFixed(1)}).`);
  }
}

// --- Acetone test animation ---
function createAcetoneAnim(type) {
  const info = getPlasticInfo(type);
  return {
    type: type,
    phase: 'falling',
    x: DISH.x + (Math.random() - 0.5) * 40,
    y: DISH.y - 80,
    vy: 0,
    scale: 1,
    alpha: 1,
    dissolves: info.dissolves,
    dissolveTime: 0,
    bubbles: [],
    logged: false,
    plasticInfo: info,
    settled: false,
  };
}

function updateAcetoneAnim(anim, dt) {
  const targetY = DISH.y - 6;

  if (anim.phase === 'falling') {
    anim.vy += GRAVITY * 0.7 * dt;
    anim.y += anim.vy * dt;

    if (anim.y >= targetY) {
      anim.y = targetY;
      anim.vy = 0;
      anim.phase = 'reacting';
    }
  }

  if (anim.phase === 'reacting') {
    if (anim.dissolves) {
      anim.dissolveTime += dt;
      anim.scale = Math.max(0, 1 - anim.dissolveTime * 0.35);
      anim.alpha = Math.max(0.05, 1 - anim.dissolveTime * 0.3);

      // Bubbles
      if (anim.scale > 0.1 && Math.random() < 0.35) {
        anim.bubbles.push({
          x: anim.x + (Math.random() - 0.5) * SAMPLE_SIZE * anim.scale,
          y: anim.y + (Math.random() - 0.5) * 10,
          vy: -Math.random() * 60 - 20,
          r: Math.random() * 4 + 1.5,
          life: 1,
        });
      }

      if (anim.scale <= 0.05) {
        anim.phase = 'done';
        anim.scale = 0;
      }

      if (!anim.logged && anim.dissolveTime > 0.5) {
        anim.logged = true;
        addLog('üß™', anim.type,
          `se dissout dans l'acetone ! Le polystyrene est soluble dans les solvants organiques.`);
      }
    } else {
      if (!anim.settled) {
        anim.settled = true;
        if (!anim.logged) {
          anim.logged = true;
          addLog('üß™', anim.type,
            `reste inerte dans l'acetone. Ce plastique n'est pas soluble.`);
        }
      }
      anim.phase = 'done';
    }
  }

  // Update bubbles
  anim.bubbles.forEach(b => {
    b.vy -= 30 * dt;
    b.y += b.vy * dt;
    b.x += Math.sin(state.time * 6 + b.x) * 0.5;
    b.life -= dt * 1.2;
    b.r *= (1 - dt * 0.5);
  });
  anim.bubbles = anim.bubbles.filter(b => b.life > 0 && b.r > 0.3);
}

function drawAcetoneAnim(cx, anim) {
  if (anim.scale > 0.01) {
    drawSample(cx, anim.x, anim.y, SAMPLE_SIZE, anim.type, anim.alpha, anim.scale, false);
  }

  // Bubbles
  anim.bubbles.forEach(b => {
    cx.globalAlpha = b.life * 0.5;
    cx.fillStyle = 'rgba(255,245,200,0.6)';
    cx.strokeStyle = 'rgba(200,180,100,0.4)';
    cx.lineWidth = 0.5;
    cx.beginPath();
    cx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    cx.fill();
    cx.stroke();
    cx.globalAlpha = 1;
  });

  // Dissolve cloud
  if (anim.dissolves && anim.dissolveTime > 0 && anim.dissolveTime < 4) {
    const cloudAlpha = Math.min(0.3, anim.dissolveTime * 0.15) * Math.max(0, 1 - anim.dissolveTime * 0.2);
    cx.fillStyle = `rgba(200,160,220,${cloudAlpha})`;
    cx.beginPath();
    cx.ellipse(anim.x, anim.y, 30 + anim.dissolveTime * 15, 15 + anim.dissolveTime * 5, 0, 0, Math.PI * 2);
    cx.fill();
  }
}

// --- Flame test animation ---
function createFlameAnim(type) {
  const info = getPlasticInfo(type);
  const targetX = BURNER.x;
  const targetY = BURNER.baseY - BURNER.tubeH - BURNER.flameH * 0.25;

  return {
    type: type,
    phase: 'approaching',
    x: BURNER.x + 140,
    y: BURNER.baseY - BURNER.tubeH - 40,
    targetX: targetX,
    targetY: targetY,
    approachT: 0,
    startX: BURNER.x + 140,
    startY: BURNER.baseY - BURNER.tubeH - 40,
    testTime: 0,
    flameGreen: 0,   // 0 = normal, 1 = full green
    darken: 0,
    hasChlorine: info.chlorine,
    logged: false,
    plasticInfo: info,
    pincerAngle: 0,
  };
}

function updateFlameAnim(anim, dt) {
  if (anim.phase === 'approaching') {
    anim.approachT += dt * 1.2;
    const t = clamp(anim.approachT, 0, 1);
    const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    anim.x = lerp(anim.startX, anim.targetX, ease);
    anim.y = lerp(anim.startY, anim.targetY, ease);

    if (t >= 1) {
      anim.phase = 'testing';
    }
  }

  if (anim.phase === 'testing') {
    anim.testTime += dt;
    if (anim.hasChlorine) {
      anim.flameGreen = clamp(anim.testTime * 0.8, 0, 1);
    } else {
      anim.darken = clamp(anim.testTime * 0.15, 0, 0.5);
    }

    if (!anim.logged && anim.testTime > 1.2) {
      anim.logged = true;
      if (anim.hasChlorine) {
        addLog('üî•', anim.type,
          `La flamme devient VERTE ! Presence de chlore detectee (test de Belstein positif).`);
      } else {
        addLog('üî•', anim.type,
          `La flamme reste jaune/orange. Pas de chlore detecte (test de Belstein negatif).`);
      }
    }

    if (anim.testTime > 4) {
      anim.phase = 'done';
    }
  }
}

function drawFlameAnim(cx, anim) {
  // Draw pincer/tongs holding the sample
  cx.save();
  cx.strokeStyle = '#888';
  cx.lineWidth = 3;
  cx.lineCap = 'round';

  // Tong arms from sample to upper-right
  const endX = anim.x + 90;
  const endY = anim.y - 70;

  cx.beginPath();
  cx.moveTo(anim.x + SAMPLE_SIZE/2 - 2, anim.y - 4);
  cx.quadraticCurveTo(anim.x + 50, anim.y - 30, endX, endY);
  cx.stroke();

  cx.beginPath();
  cx.moveTo(anim.x + SAMPLE_SIZE/2 - 2, anim.y + 4);
  cx.quadraticCurveTo(anim.x + 50, anim.y - 25, endX, endY - 6);
  cx.stroke();

  // Handle
  cx.lineWidth = 5;
  cx.strokeStyle = '#a07040';
  cx.beginPath();
  cx.moveTo(endX, endY);
  cx.lineTo(endX + 35, endY - 25);
  cx.stroke();
  cx.restore();

  // Draw sample
  drawSample(cx, anim.x, anim.y, SAMPLE_SIZE, anim.type, 1, 1, anim.darken > 0.1);
}

function getFlameColor(anim) {
  if (!anim) return '#ee8833';
  const base = '#ee8833';
  const green = '#22dd44';
  return blendColor(base, green, anim.flameGreen || 0);
}

// ==================== MAIN RENDER ====================
function renderScene() {
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

  // Background
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(0,0,0,0.03)';
  ctx.lineWidth = 1;
  for (let gx = 0; gx < CANVAS_W; gx += 30) {
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, CANVAS_H); ctx.stroke();
  }
  for (let gy = 0; gy < CANVAS_H; gy += 30) {
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(CANVAS_W, gy); ctx.stroke();
  }

  // Work surface
  ctx.fillStyle = '#e8e0d4';
  ctx.fillRect(0, CANVAS_H - 35, CANVAS_W, 35);
  ctx.strokeStyle = '#c8bfb0';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, CANVAS_H - 35);
  ctx.lineTo(CANVAS_W, CANVAS_H - 35);
  ctx.stroke();

  const test = state.currentTest;

  if (test === 'A') {
    drawBeaker(ctx, 'rgba(130,195,255,0.45)', 'Eau douce', 1.0);
    if (state.anim) drawDensityAnim(ctx, state.anim);
  } else if (test === 'B') {
    drawBeaker(ctx, 'rgba(80,140,210,0.5)', 'Eau salee saturee', 1.2);
    if (state.anim) drawDensityAnim(ctx, state.anim);
  } else if (test === 'C') {
    drawDish(ctx);
    if (state.anim) drawAcetoneAnim(ctx, state.anim);
  } else if (test === 'D') {
    drawBunsenBurner(ctx);
    const fc = getFlameColor(state.anim);
    drawFlame(ctx, BURNER.x, BURNER.baseY - BURNER.tubeH, fc, state.time);
    if (state.anim) drawFlameAnim(ctx, state.anim);
  }

  // Drop zone indicator when dragging
  if (state.dragging) {
    ctx.strokeStyle = 'rgba(44,111,187,0.35)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    drawRoundRect(ctx, 40, 30, CANVAS_W - 80, CANVAS_H - 80, 16);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(44,111,187,0.08)';
    drawRoundRect(ctx, 40, 30, CANVAS_W - 80, CANVAS_H - 80, 16);
    ctx.fill();

    // Arrow down hint
    ctx.fillStyle = 'rgba(44,111,187,0.2)';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Relacher ici', CANVAS_W/2, CANVAS_H/2 - (state.anim ? 0 : 0));
  }

  // Mode label
  const modeLabels = { A: 'Test de densite (eau douce)', B: 'Test de densite (eau salee)', C: 'Test a l\'acetone', D: 'Test de flamme (Belstein)' };
  ctx.fillStyle = 'rgba(44,111,187,0.7)';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(modeLabels[test], 15, 12);
}

// ==================== GAME LOOP ====================
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;
  state.time += dt;

  // Update animation
  if (state.anim) {
    const test = state.currentTest;
    if (test === 'A' || test === 'B') {
      updateDensityAnim(state.anim, dt);
    } else if (test === 'C') {
      updateAcetoneAnim(state.anim, dt);
    } else if (test === 'D') {
      updateFlameAnim(state.anim, dt);
    }
  }

  renderScene();
  requestAnimationFrame(gameLoop);
}

// ==================== DRAG & DROP ====================
function startDrag(type, e) {
  if (state.anim && state.anim.phase !== 'settled' && state.anim.phase !== 'done') return;

  const ghost = document.createElement('div');
  ghost.className = 'drag-ghost';
  const c = type === 'MYSTERY' ? 'linear-gradient(135deg, #f7dc6f, #f0b27a, #bb8fce, #76d7c4)' : getSampleColor(type);
  ghost.innerHTML = `<div class="swatch" style="background:${c};">${getDisplayName(type)}</div>`;
  document.body.appendChild(ghost);

  const clientX = e.clientX || (e.touches && e.touches[0].clientX);
  const clientY = e.clientY || (e.touches && e.touches[0].clientY);
  ghost.style.left = clientX + 'px';
  ghost.style.top = clientY + 'px';

  state.dragging = { type, ghostEl: ghost };
}

function moveDrag(e) {
  if (!state.dragging) return;
  const clientX = e.clientX || (e.touches && e.touches[0].clientX);
  const clientY = e.clientY || (e.touches && e.touches[0].clientY);
  state.dragging.ghostEl.style.left = clientX + 'px';
  state.dragging.ghostEl.style.top = clientY + 'px';
  state.mouseX = clientX;
  state.mouseY = clientY;
}

function endDrag(e) {
  if (!state.dragging) return;
  const ghost = state.dragging.ghostEl;
  const type = state.dragging.type;

  // Check if dropped on canvas
  const rect = canvas.getBoundingClientRect();
  const mx = state.mouseX;
  const my = state.mouseY;

  if (mx >= rect.left && mx <= rect.right && my >= rect.top && my <= rect.bottom) {
    // Start test animation
    startTest(type);
  }

  ghost.remove();
  state.dragging = null;
}

function startTest(type) {
  const test = state.currentTest;
  if (test === 'A') {
    state.anim = createDensityAnim(type, 1.0);
  } else if (test === 'B') {
    state.anim = createDensityAnim(type, 1.2);
  } else if (test === 'C') {
    state.anim = createAcetoneAnim(type);
  } else if (test === 'D') {
    state.anim = createFlameAnim(type);
  }
}

// ==================== EVENT LISTENERS ====================
// Sample buttons - drag
document.querySelectorAll('.sample-btn').forEach(btn => {
  const type = btn.dataset.type;

  btn.addEventListener('mousedown', e => { e.preventDefault(); startDrag(type, e); });
  btn.addEventListener('touchstart', e => { e.preventDefault(); startDrag(type, e); }, { passive: false });
});

document.addEventListener('mousemove', moveDrag);
document.addEventListener('touchmove', e => { e.preventDefault(); moveDrag(e); }, { passive: false });
document.addEventListener('mouseup', endDrag);
document.addEventListener('touchend', endDrag);

// Tool buttons
document.querySelectorAll('.tool-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.currentTest = btn.dataset.test;
    state.anim = null; // Reset animation on test change
  });
});

// Reset button
document.getElementById('reset-btn').addEventListener('click', () => {
  state.anim = null;
  state.logs = [];
  logList.innerHTML = '';
  document.getElementById('validation-result').textContent = '';
  document.getElementById('validation-result').className = '';
  document.getElementById('guess-select').value = '';
  state.solved = false;
  addLog('üîÑ', 'SYS', 'Simulation reinitialisee. L\'echantillon mystere a ete conserve.');
});

// Validation
document.getElementById('validate-btn').addEventListener('click', () => {
  const guess = document.getElementById('guess-select').value;
  const result = document.getElementById('validation-result');
  if (!guess) {
    result.textContent = 'Veuillez selectionner un type de plastique.';
    result.className = 'fail';
    return;
  }
  if (guess === state.mysteryType) {
    result.textContent = `Bravo ! L'echantillon mystere est bien du ${guess} (${PLASTICS[guess].fullName}) !`;
    result.className = 'success';
    if (!state.solved) {
      state.solved = true;
      launchConfetti();
    }
  } else {
    result.textContent = `Ce n'est pas du ${guess}. Continuez vos tests !`;
    result.className = 'fail';
  }
});

// ==================== CONFETTI ====================
let confettiParticles = [];
let confettiActive = false;

function launchConfetti() {
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
  confettiParticles = [];
  confettiActive = true;

  const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22', '#1abc9c', '#f1c40f'];
  for (let i = 0; i < 150; i++) {
    confettiParticles.push({
      x: Math.random() * confettiCanvas.width,
      y: Math.random() * -confettiCanvas.height,
      vx: (Math.random() - 0.5) * 200,
      vy: Math.random() * 200 + 100,
      w: Math.random() * 10 + 4,
      h: Math.random() * 6 + 3,
      color: colors[Math.floor(Math.random() * colors.length)],
      rotation: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 400,
      life: 1,
    });
  }
  animateConfetti();
}

function animateConfetti() {
  if (!confettiActive) return;
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

  let alive = 0;
  confettiParticles.forEach(p => {
    p.x += p.vx * 0.016;
    p.vy += 150 * 0.016;
    p.y += p.vy * 0.016;
    p.rotation += p.rotSpeed * 0.016;
    p.life -= 0.003;

    if (p.life > 0 && p.y < confettiCanvas.height + 50) {
      alive++;
      confettiCtx.save();
      confettiCtx.globalAlpha = Math.min(1, p.life * 2);
      confettiCtx.translate(p.x, p.y);
      confettiCtx.rotate(p.rotation * Math.PI / 180);
      confettiCtx.fillStyle = p.color;
      confettiCtx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      confettiCtx.restore();
    }
  });

  if (alive > 0) {
    requestAnimationFrame(animateConfetti);
  } else {
    confettiActive = false;
    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  }
}

// ==================== INIT ====================
function init() {
  dropHint.style.display = 'none';
  addLog('üßë‚Äçüî¨', 'SYS', 'Bienvenue ! Selectionnez un test a droite, puis glissez un echantillon sur le plan de travail.');
  addLog('üéØ', 'SYS', `Objectif : identifier l'echantillon mystere "?" en effectuant differents tests.`);
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
